{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/acer08022023/Desktop/defi-staking-app-starter-main/defi-staking-app-starter/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/acer08022023/Desktop/defi-staking-app-starter-main/defi-staking-app-starter/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\nvar EthersTransactionUtils = require('@ethersproject/transactions');\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n\n  this.requestManager = options.requestManager;\n\n  // reference to eth.accounts\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n  this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n  this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n  this.defaultCommon = options.defaultCommon;\n  this.defaultChain = options.defaultChain;\n  this.defaultHardfork = options.defaultHardfork;\n  this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager;\n\n  // reference to eth.accounts\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n  if (!this.inputFormatter) {\n    return args;\n  }\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n  return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n    promiseResolved = false,\n    canUnsubscribe = true,\n    timeoutCount = 0,\n    confirmationCount = 0,\n    intervalId = null,\n    lastBlock = null,\n    receiptJSON = '',\n    gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n    isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to,\n    hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n\n  // add custom send Methods\n  var _ethereumCalls = [new Method({\n    name: 'getBlockByNumber',\n    call: 'eth_getBlockByNumber',\n    params: 2,\n    inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n      return !!val;\n    }],\n    outputFormatter: formatters.outputBlockFormatter\n  }), new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Method({\n    name: 'getTransactionByHash',\n    call: 'eth_getTransactionByHash',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionFormatter\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })];\n  // attach methods to this._ethereumCall\n  var _ethereumCall = {};\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  });\n\n  // fire \"receipt\" and confirmation events and resolve after\n  var checkConfirmation = function checkConfirmation(existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function unsubscribe() {\n            clearInterval(intervalId);\n          }\n        };\n      }\n      // if we have a valid receipt we don't need to send a request\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)\n      // catch error from requesting receipt\n      ).catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      })\n      // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(receipt) {\n          var block, latestBlock, latestBlockHash;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!receipt || !receipt.blockHash)) {\n                  _context.next = 2;\n                  break;\n                }\n                throw new Error('Receipt missing or blockHash null');\n              case 2:\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                  receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n\n                // check if confirmation listener exists\n                if (!(defer.eventEmitter.listeners('confirmation').length > 0)) {\n                  _context.next = 28;\n                  break;\n                }\n                if (!(existingReceipt === undefined || confirmationCount !== 0)) {\n                  _context.next = 25;\n                  break;\n                }\n                _context.next = 7;\n                return _ethereumCall.getBlockByNumber('latest');\n              case 7:\n                latestBlock = _context.sent;\n                latestBlockHash = latestBlock ? latestBlock.hash : null;\n                if (!isPolling) {\n                  _context.next = 24;\n                  break;\n                }\n                if (!lastBlock) {\n                  _context.next = 17;\n                  break;\n                }\n                _context.next = 13;\n                return _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n              case 13:\n                block = _context.sent;\n                if (block) {\n                  lastBlock = block;\n                  defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                }\n                _context.next = 22;\n                break;\n              case 17:\n                _context.next = 19;\n                return _ethereumCall.getBlockByNumber(receipt.blockNumber);\n              case 19:\n                block = _context.sent;\n                lastBlock = block;\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n              case 22:\n                _context.next = 25;\n                break;\n              case 24:\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n              case 25:\n                if (isPolling && block || !isPolling) {\n                  confirmationCount++;\n                }\n                canUnsubscribe = false;\n                if (confirmationCount === method.transactionConfirmationBlocks + 1) {\n                  // add 1 so we account for conf 0\n                  sub.unsubscribe();\n                  defer.eventEmitter.removeAllListeners();\n                }\n              case 28:\n                return _context.abrupt(\"return\", receipt);\n              case 29:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }())\n      // CHECK for CONTRACT DEPLOYMENT\n      .then( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(receipt) {\n          var code, deploymentSuccess;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(isContractDeployment && !promiseResolved)) {\n                  _context2.next = 19;\n                  break;\n                }\n                if (receipt.contractAddress) {\n                  _context2.next = 5;\n                  break;\n                }\n                if (canUnsubscribe) {\n                  sub.unsubscribe();\n                  promiseResolved = true;\n                }\n                utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                return _context2.abrupt(\"return\");\n              case 5:\n                _context2.prev = 5;\n                _context2.next = 8;\n                return _ethereumCall.getCode(receipt.contractAddress);\n              case 8:\n                code = _context2.sent;\n                _context2.next = 13;\n                break;\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](5);\n              case 13:\n                if (code) {\n                  _context2.next = 15;\n                  break;\n                }\n                return _context2.abrupt(\"return\");\n              case 15:\n                // If deployment is status.true and there was a real\n                // bytecode string, assume it was successful.\n                deploymentSuccess = receipt.status === true && hasBytecode;\n                if (deploymentSuccess || code.length > 2) {\n                  defer.eventEmitter.emit('receipt', receipt);\n\n                  // if contract, return instance instead of receipt\n                  if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                    defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                  } else {\n                    defer.resolve(receipt);\n                  }\n\n                  // need to remove listeners, as they aren't removed automatically when succesfull\n                  if (canUnsubscribe) {\n                    defer.eventEmitter.removeAllListeners();\n                  }\n                } else {\n                  utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                }\n                if (canUnsubscribe) {\n                  sub.unsubscribe();\n                }\n                promiseResolved = true;\n              case 19:\n                return _context2.abrupt(\"return\", receipt);\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2, null, [[5, 11]]);\n        }));\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }())\n      // CHECK for normal tx check for receipt only\n      .then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(receipt) {\n          var revertMessage, txReplayOptions, rawTransactionHex, parsedTx;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(!isContractDeployment && !promiseResolved)) {\n                  _context3.next = 35;\n                  break;\n                }\n                if (!(!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined'))) {\n                  _context3.next = 7;\n                  break;\n                }\n                defer.eventEmitter.emit('receipt', receipt);\n                defer.resolve(receipt);\n\n                // need to remove listeners, as they aren't removed automatically when succesfull\n                if (canUnsubscribe) {\n                  defer.eventEmitter.removeAllListeners();\n                }\n                _context3.next = 33;\n                break;\n              case 7:\n                receiptJSON = JSON.stringify(receipt, null, 2);\n                if (!(receipt.status === false || receipt.status === '0x0')) {\n                  _context3.next = 32;\n                  break;\n                }\n                _context3.prev = 9;\n                revertMessage = null;\n                if (!(method.handleRevert && (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'))) {\n                  _context3.next = 24;\n                  break;\n                }\n                txReplayOptions = payload.params[0]; // If send was raw, fetch the transaction and reconstitute the\n                // original params so they can be replayed with `eth_call`\n                if (method.call === 'eth_sendRawTransaction') {\n                  rawTransactionHex = payload.params[0];\n                  parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                  txReplayOptions = formatters.inputTransactionFormatter({\n                    data: parsedTx.data,\n                    to: parsedTx.to,\n                    from: parsedTx.from,\n                    gas: parsedTx.gasLimit.toHexString(),\n                    gasPrice: parsedTx.gasPrice.toHexString(),\n                    value: parsedTx.value.toHexString()\n                  });\n                }\n\n                // Get revert reason string with eth_call\n                _context3.next = 16;\n                return method.getRevertReason(txReplayOptions, receipt.blockNumber);\n              case 16:\n                revertMessage = _context3.sent;\n                if (!revertMessage) {\n                  _context3.next = 21;\n                  break;\n                }\n                // Only throw a revert error if a revert reason is existing\n                utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                _context3.next = 22;\n                break;\n              case 21:\n                throw false;\n              case 22:\n                _context3.next = 25;\n                break;\n              case 24:\n                throw false;\n              case 25:\n                _context3.next = 30;\n                break;\n              case 27:\n                _context3.prev = 27;\n                _context3.t0 = _context3[\"catch\"](9);\n                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              case 30:\n                _context3.next = 33;\n                break;\n              case 32:\n                // Throw OOG if status is not existing and provided gas and used gas are equal\n                utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              case 33:\n                if (canUnsubscribe) {\n                  sub.unsubscribe();\n                }\n                promiseResolved = true;\n              case 35:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3, null, [[9, 27]]);\n        }));\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }())\n      // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++;\n\n        // check to see if we are http polling\n        if (!!isPolling) {\n          // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n          if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  };\n\n  // start watching for confirmation depending on the support features of the provider\n  var startWatching = function (existingReceipt) {\n    var startInterval = function startInterval() {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    };\n    if (!this.requestManager.provider.on) {\n      startInterval();\n    } else {\n      _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n        if (err || !blockHeader) {\n          // fall back to polling\n          startInterval();\n        } else {\n          checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n        }\n      });\n    }\n  }.bind(this);\n\n  // first check if we already have a confirmed transaction\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\nvar getWallet = function getWallet(from, accounts) {\n  var wallet = null;\n\n  // is index given\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from];\n\n    // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from;\n\n    // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n  return wallet;\n};\nMethod.prototype.buildCall = function () {\n  var method = this,\n    isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction',\n    // || method.call === 'personal_sendTransaction'\n    isCall = method.call === 'eth_call';\n\n  // actual send function\n  var send = function send() {\n    var defer = promiEvent(!isSendTx),\n      payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n    // CALLBACK function\n    var sendTxCallback = function sendTxCallback(err, result) {\n      if (method.handleRevert && isCall && method.abiCoder) {\n        var reasonData;\n\n        // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n        // Geth >= 1.9.15 attaches the reason data to an error object.\n        // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n        if (!err && method.isRevertReasonString(result)) {\n          reasonData = result.substring(10);\n        } else if (err && err.data) {\n          reasonData = err.data.substring(10);\n        }\n        if (reasonData) {\n          var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n          var signature = 'Error(String)';\n          utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n            reason: reason,\n            signature: signature\n          });\n          return;\n        }\n      }\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n      if (result instanceof Error) {\n        err = result;\n      }\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      }\n\n      // return PROMISE\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        }\n\n        // return PROMIEVENT\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n        method._confirmTransaction(defer, result, payload);\n      }\n    };\n\n    // SENDS the SIGNED SIGNATURE\n    var sendSignedTx = function sendSignedTx(sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n    var sendRequest = function sendRequest(payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet;\n\n        // ETH_SENDTRANSACTION\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts);\n\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var txOptions = _.omit(tx, 'from');\n            if (method.defaultChain && !txOptions.chain) {\n              txOptions.chain = method.defaultChain;\n            }\n            if (method.defaultHardfork && !txOptions.hardfork) {\n              txOptions.hardfork = method.defaultHardfork;\n            }\n            if (method.defaultCommon && !txOptions.common) {\n              txOptions.common = method.defaultCommon;\n            }\n            return method.accounts.signTransaction(txOptions, wallet.privateKey).then(sendSignedTx).catch(function (err) {\n              if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                defer.eventEmitter.emit('error', err);\n                defer.eventEmitter.removeAllListeners();\n                defer.eventEmitter.catch(function () {});\n              }\n              defer.reject(err);\n            });\n          }\n\n          // ETH_SIGN\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts);\n\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n      return method.requestManager.send(payload, sendTxCallback);\n    };\n\n    // Send the actual transaction\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n        if (isSendTx) {\n          setTimeout(function () {\n            defer.eventEmitter.emit('sending', payload);\n          }, 0);\n        }\n        sendRequest(payload, method);\n      });\n    } else {\n      if (isSendTx) {\n        setTimeout(function () {\n          defer.eventEmitter.emit('sending', payload);\n        }, 0);\n      }\n      sendRequest(payload, method);\n    }\n    if (isSendTx) {\n      setTimeout(function () {\n        defer.eventEmitter.emit('sent', payload);\n      }, 0);\n    }\n    return defer.eventEmitter;\n  };\n\n  // necessary to attach things to the method\n  send.method = method;\n  // necessary for batch requests\n  send.request = this.request.bind(this);\n  return send;\n};\n\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    new Method({\n      name: 'call',\n      call: 'eth_call',\n      params: 2,\n      abiCoder: self.abiCoder,\n      handleRevert: true\n    }).createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber)).then(function () {\n      resolve(false);\n    }).catch(function (error) {\n      if (error.reason) {\n        resolve({\n          reason: error.reason,\n          signature: error.signature\n        });\n      } else {\n        reject(error);\n      }\n    });\n  });\n};\n\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n  return _.isString(data) && (data.length - 2) / 2 % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\nmodule.exports = Method;","map":{"version":3,"names":["_regeneratorRuntime","require","default","_asyncToGenerator","_","errors","formatters","utils","promiEvent","Subscriptions","subscriptions","EthersTransactionUtils","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","abiCoder","requestManager","accounts","defaultBlock","defaultAccount","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","defaultCommon","defaultChain","defaultHardfork","handleRevert","prototype","setRequestManager","createFunction","func","buildCall","attachToObject","obj","split","length","getCall","args","isFunction","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","isArray","res","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","lastBlock","receiptJSON","gasProvided","isObject","gas","isContractDeployment","data","from","to","hasBytecode","_ethereumCalls","inputBlockNumberFormatter","val","outputBlockFormatter","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","outputTransactionFormatter","type","subscriptionName","_ethereumCall","each","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","_ref","mark","_callee","receipt","block","latestBlock","latestBlockHash","wrap","_callee$","_context","prev","next","blockHash","receiptFormatter","listeners","undefined","getBlockByNumber","sent","hash","number","emit","blockNumber","removeAllListeners","abrupt","stop","_x","apply","arguments","_ref2","_callee2","code","deploymentSuccess","_callee2$","_context2","contractAddress","NoContractAddressFoundError","getCode","t0","status","contractDeployFormatter","ContractCodeNotStoredError","_x2","_ref3","_callee3","revertMessage","txReplayOptions","rawTransactionHex","parsedTx","_callee3$","_context3","outOfGas","gasUsed","JSON","stringify","parse","inputTransactionFormatter","gasLimit","toHexString","gasPrice","value","getRevertReason","TransactionRevertInstructionError","reason","signature","TransactionRevertedWithoutReasonError","TransactionOutOfGasError","_x3","TransactionError","startWatching","startInterval","setInterval","bind","provider","on","subscribe","getWallet","wallet","isNumber","address","privateKey","toLowerCase","isSendTx","isCall","send","Array","slice","sendTxCallback","reasonData","isRevertReasonString","substring","decodeParameter","RevertInstructionError","e","error","sendSignedTx","sign","signedPayload","extend","rawTransaction","sendRequest","tx","txOptions","omit","chain","hardfork","common","signTransaction","getGasPrice","setTimeout","request","self","Promise","numberToHex","isString","format","module","exports"],"sources":["C:/Users/acer08022023/desktop/defi-staking-app-starter-main/defi-staking-app-starter/node_modules/web3-core-method/src/index.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n'use strict';\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar EthersTransactionUtils = require('@ethersproject/transactions');\n\nvar Method = function Method(options) {\n\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n\n    this.requestManager = options.requestManager;\n\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n\n    return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    } else {\n        obj[name[0]] = func;\n    }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n\n    if (!this.inputFormatter) {\n        return args;\n    }\n\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n\n    if (_.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    } else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n\n    return payload;\n};\n\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this,\n        promiseResolved = false,\n        canUnsubscribe = true,\n        timeoutCount = 0,\n        confirmationCount = 0,\n        intervalId = null,\n        lastBlock = null,\n        receiptJSON = '',\n        gasProvided = (_.isObject(payload.params[0]) && payload.params[0].gas) ? payload.params[0].gas : null,\n        isContractDeployment = _.isObject(payload.params[0]) &&\n            payload.params[0].data &&\n            payload.params[0].from &&\n            !payload.params[0].to,\n        hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                return !!val;\n            }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getTransactionByHash',\n            call: 'eth_getTransactionByHash',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionFormatter\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads', // replace subscription with this name\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _.each(_ethereumCalls, function (mthd) {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n\n\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n            // catch error from requesting receipt\n                .catch(function (err) {\n                    sub.unsubscribe();\n                    promiseResolved = true;\n                    utils._fireError(\n                        {\n                            message: 'Failed to check for transaction receipt:',\n                            data: err\n                        },\n                        defer.eventEmitter,\n                        defer.reject\n                    );\n                })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                    if (!receipt || !receipt.blockHash) {\n                        throw new Error('Receipt missing or blockHash null');\n                    }\n\n                    // apply extra formatters\n                    if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                        receipt = method.extraFormatters.receiptFormatter(receipt);\n                    }\n\n                    // check if confirmation listener exists\n                    if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                        var block;\n\n                        // If there was an immediately retrieved receipt, it's already\n                        // been confirmed by the direct call to checkConfirmation needed\n                        // for parity instant-seal\n                        if (existingReceipt === undefined || confirmationCount !== 0) {\n                            // Get latest block to emit with confirmation\n                            var latestBlock = await _ethereumCall.getBlockByNumber('latest');\n                            var latestBlockHash = latestBlock ? latestBlock.hash : null;\n\n                            if (isPolling) { // Check if actually a new block is existing on polling\n                                if (lastBlock) {\n                                    block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                    if (block) {\n                                        lastBlock = block;\n                                        defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                                    }\n                                } else {\n                                    block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                                }\n                            } else {\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                            }\n                        }\n\n                        if ((isPolling && block) || !isPolling) {\n                            confirmationCount++;\n                        }\n                        canUnsubscribe = false;\n\n                        if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                            sub.unsubscribe();\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n\n                    return receipt;\n                })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n\n                    if (isContractDeployment && !promiseResolved) {\n\n                        if (!receipt.contractAddress) {\n\n                            if (canUnsubscribe) {\n                                sub.unsubscribe();\n                                promiseResolved = true;\n                            }\n\n                            utils._fireError(\n                                errors.NoContractAddressFoundError(receipt),\n                                defer.eventEmitter,\n                                defer.reject,\n                                null,\n                                receipt\n                            );\n                            return;\n                        }\n\n                        var code;\n                        try {\n                            code = await _ethereumCall.getCode(receipt.contractAddress);\n                        } catch(err){\n                            // ignore;\n                        }\n\n                        if (!code) {\n                            return;\n                        }\n\n                        // If deployment is status.true and there was a real\n                        // bytecode string, assume it was successful.\n                        var deploymentSuccess = receipt.status === true && hasBytecode;\n\n                        if (deploymentSuccess || code.length > 2) {\n                            defer.eventEmitter.emit('receipt', receipt);\n\n                            // if contract, return instance instead of receipt\n                            if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                            } else {\n                                defer.resolve(receipt);\n                            }\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            utils._fireError(\n                                errors.ContractCodeNotStoredError(receipt),\n                                defer.eventEmitter,\n                                defer.reject,\n                                null,\n                                receipt\n                            );\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    }\n\n                    return receipt;\n                })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                    if (!isContractDeployment && !promiseResolved) {\n                        if (!receipt.outOfGas &&\n                            (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                            (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                            defer.eventEmitter.emit('receipt', receipt);\n                            defer.resolve(receipt);\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            receiptJSON = JSON.stringify(receipt, null, 2);\n\n                            if (receipt.status === false || receipt.status === '0x0') {\n                                try {\n                                    var revertMessage = null;\n\n                                    if ( method.handleRevert &&\n                                        (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'))\n                                    {\n                                        var txReplayOptions = payload.params[0];\n\n                                        // If send was raw, fetch the transaction and reconstitute the\n                                        // original params so they can be replayed with `eth_call`\n                                        if (method.call === 'eth_sendRawTransaction'){\n                                            var rawTransactionHex = payload.params[0];\n\n                                            var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n\n                                            txReplayOptions = formatters.inputTransactionFormatter({\n                                                data: parsedTx.data,\n                                                to: parsedTx.to,\n                                                from: parsedTx.from,\n                                                gas: parsedTx.gasLimit.toHexString(),\n                                                gasPrice: parsedTx.gasPrice.toHexString(),\n                                                value: parsedTx.value.toHexString()\n                                            })\n                                        }\n\n                                        // Get revert reason string with eth_call\n                                        revertMessage = await method.getRevertReason(\n                                            txReplayOptions,\n                                            receipt.blockNumber\n                                        );\n\n                                        if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                            utils._fireError(\n                                                errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt),\n                                                defer.eventEmitter,\n                                                defer.reject,\n                                                null,\n                                                receipt\n                                            );\n                                        } else {\n                                            throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                        }\n                                    } else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                } catch (error) {\n                                    // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                    utils._fireError(\n                                        errors.TransactionRevertedWithoutReasonError(receipt),\n                                        defer.eventEmitter,\n                                        defer.reject,\n                                        null,\n                                        receipt\n                                    );\n                                }\n                            } else {\n                                // Throw OOG if status is not existing and provided gas and used gas are equal\n                                utils._fireError(\n                                    errors.TransactionOutOfGasError(receipt),\n                                    defer.eventEmitter,\n                                    defer.reject,\n                                    null,\n                                    receipt\n                                );\n                            }\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    }\n\n                })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                    timeoutCount++;\n\n                    // check to see if we are http polling\n                    if (!!isPolling) {\n                        // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                        if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                            utils._fireError(\n                                errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'),\n                                defer.eventEmitter,\n                                defer.reject\n                            );\n                        }\n                    } else {\n                        if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                            utils._fireError(\n                                errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'),\n                                defer.eventEmitter,\n                                defer.reject\n                            );\n                        }\n                    }\n                });\n\n\n        } else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        const startInterval = () => {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        }\n\n        if (!this.requestManager.provider.on) {\n            startInterval()\n        } else {\n            _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n                if (err || !blockHeader) {\n                    // fall back to polling\n                    startInterval()\n                } else {\n                    checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n                }\n            })\n        }\n    }.bind(this);\n\n\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n            if (receipt && receipt.blockHash) {\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    // We must keep on watching for new Blocks, if a confirmation listener is present\n                    startWatching(receipt);\n                }\n                checkConfirmation(receipt, false);\n\n            } else if (!promiseResolved) {\n                startWatching();\n            }\n        })\n        .catch(function () {\n            if (!promiseResolved) startWatching();\n        });\n\n};\n\n\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n\n    // is index given\n    if (_.isNumber(from)) {\n        wallet = accounts.wallet[from];\n\n        // is account given\n    } else if (_.isObject(from) && from.address && from.privateKey) {\n        wallet = from;\n\n        // search in wallet for address\n    } else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n\n    return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n    var method = this,\n        isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n        isCall = (method.call === 'eth_call');\n\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx),\n            payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && isCall && method.abiCoder) {\n                var reasonData;\n\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n                // Geth >= 1.9.15 attaches the reason data to an error object.\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n                if (!err && method.isRevertReasonString(result)){\n                    reasonData = result.substring(10);\n                } else if (err && err.data){\n                    reasonData = err.data.substring(10);\n                }\n\n                if (reasonData){\n                    var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n                    var signature = 'Error(String)';\n\n                    utils._fireError(\n                        errors.RevertInstructionError(reason, signature),\n                        defer.eventEmitter,\n                        defer.reject,\n                        payload.callback,\n                        {\n                            reason: reason,\n                            signature: signature\n                        }\n                    );\n\n                    return;\n                }\n            }\n\n            try {\n                result = method.formatOutput(result);\n            } catch (e) {\n                err = e;\n            }\n\n            if (result instanceof Error) {\n                err = result;\n            }\n\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            } else {\n                if (err.error) {\n                    err = err.error;\n                }\n\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n\n                // return PROMIEVENT\n            } else {\n                defer.eventEmitter.emit('transactionHash', result);\n\n                method._confirmTransaction(defer, result, payload);\n            }\n\n        };\n\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n\n            var signedPayload = _.extend({}, payload, {\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            });\n\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n\n\n        var sendRequest = function (payload, method) {\n\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((_.isObject(tx)) ? tx.from : null, method.accounts);\n\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var txOptions = _.omit(tx, 'from');\n\n                        if (method.defaultChain && !txOptions.chain) {\n                            txOptions.chain = method.defaultChain;\n                        }\n\n                        if (method.defaultHardfork && !txOptions.hardfork) {\n                            txOptions.hardfork = method.defaultHardfork;\n                        }\n\n                        if (method.defaultCommon && !txOptions.common) {\n                            txOptions.common = method.defaultCommon;\n                        }\n\n                        return method.accounts.signTransaction(txOptions, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                                if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                                    defer.eventEmitter.emit('error', err);\n                                    defer.eventEmitter.removeAllListeners();\n                                    defer.eventEmitter.catch(function () {\n                                    });\n                                }\n                                defer.reject(err);\n                            });\n                    }\n\n                    // ETH_SIGN\n                } else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n\n\n                }\n            }\n\n\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n\n        // Send the actual transaction\n        if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n\n            getGasPrice(function (err, gasPrice) {\n\n                if (gasPrice) {\n                    payload.params[0].gasPrice = gasPrice;\n                }\n\n                if (isSendTx) {\n                    setTimeout(() => {\n                        defer.eventEmitter.emit('sending', payload);\n                    }, 0);\n                }\n\n                sendRequest(payload, method);\n            });\n\n        } else {\n            if (isSendTx) {\n                setTimeout(() => {\n                    defer.eventEmitter.emit('sending', payload);\n                }, 0);\n            }\n\n            sendRequest(payload, method);\n        }\n\n        if (isSendTx) {\n            setTimeout(() => {\n                defer.eventEmitter.emit('sent', payload);\n            }, 0);\n        }\n\n        return defer.eventEmitter;\n    };\n\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\n\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n                resolve(false);\n            })\n            .catch(function (error) {\n                if (error.reason) {\n                    resolve({\n                        reason: error.reason,\n                        signature: error.signature\n                    });\n                } else {\n                    reject(error);\n                }\n            });\n    });\n};\n\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return _.isString(data) && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\n\nmodule.exports = Method;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}